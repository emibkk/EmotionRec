from keras.preprocessing.image import ImageDataGenerator
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
import os
from matplotlib import pyplot as plt
import numpy as np

# Datagen to manipulate the image data after it is loaded, including pixel scaling and data augmentation
train_datagen = ImageDataGenerator(
    rescale=1. / 255,
    rotation_range=30,
    shear_range=0.3,
    zoom_range=0.3,
    horizontal_flip=True,
    fill_mode='nearest')

test_datagen = ImageDataGenerator(rescale=1. / 255)

# Generator to load images from dataset
# Load and iterate training dataset
train_iter = train_datagen.flow_from_directory(
    'C:/data/train',
    color_mode='grayscale',
    target_size=(48, 48),
    batch_size=32, # 32 randomly selected images from across the classes in the dataset will be returned in each batch when training
    class_mode='categorical', # multi-class classification (categorical) becuase of 7 possible emotisonal classes. Not binary
    shuffle=True)

# Load and iterate validation dataset
test_iter = test_datagen.flow_from_directory(
    'C:/data/test',
    color_mode='grayscale',
    target_size=(48, 48),
    batch_size=32, #32 randomly selected images from across the classes in the dataset will be returned in each batch when training
    class_mode='categorical', #multi-class classification (categorical) becuase of 7 possible emotional classes. Not binary
    shuffle=True)

# Verify our generator by plotting a few faces and printing corresponding labels
class_labels = ['Angry', 'Disgust', 'Fear', 'Happy', 'Neutral', 'Sad', 'Surprise']

# Returning batches of image samples
img, label = train_iter.__next__()

# Show sample image and label
image = img[1]
labl = class_labels[label[1].argmax()]
plt.imshow(image[:, :, 0], cmap='gray')
plt.title(labl)
plt.show()

##########################################################
# Create model 
##########################################################

# Importing the important libraries
import tensorflow.keras.applications.ResNet50
from keras.applications.resnet50 import ResNet50
from keras.layers import Dense, GlobalAveragePooling2D
from keras.models import Model
from keras.optimizers import SGD
from keras.preprocessing.image import ImageDataGenerator

# Download the architecture of ResNet50 with ImageNet weights
base_model = ResNet50(include_top=False, weights='imagenet')
# Taking the output of the last convolution block in ResNet50
x = base_model.output

# Adding a Global Average Pooling layer
x = GlobalAveragePooling2D()(x)

# Adding a fully connected layer having 1024 neurons
x = Dense(1024, activation='relu')(x)

# Adding a fully connected layer having 2 neurons which will
# give the probability of image having either dog or cat
predictions = Dense(2, activation='softmax')(x)

# Model to be trained
model = Model(inputs=base_model.input, outputs=predictions)

# Training only top layers i.e. the layers which we have added in the end
for layer in base_model.layers:
    layer.trainable = False

# Compiling the model
model.compile(optimizer=SGD(lr=0.0001, momentum=0.9), loss='categorical_crossentropy', metrics=['accuracy'])

# Training the model for 5 epochs
model.fit_generator(train_iter,
                    steps_per_epoch=8000,
                    epochs=5,
                    validation_data=test_iter,
                    validation_steps=2000)

# We will try to train the last stage of ResNet50
for layer in base_model.layers[0:143]:
    layer.trainable = False

for layer in base_model.layers[143:]:
    layer.trainable = True

# Training the model for 10 epochs
model.fit_generator(train_iter,
                    steps_per_epoch=8000,
                    epochs=10,
                    validation_data=test_iter,
                    validation_steps=2000)

# Saving the weights in the current directory
model.save_weights("resnet50_weights.h5")

# Predicting the final result of image
from keras.preprocessing import image

test_image = image.load_img('cat_or_dog_test.jpg', target_size=(224, 224))
test_image = image.img_to_array(test_image) \
 \
    # Expanding the 3-d image to 4-d image.
# The dimensions will be Batch, Height, Width, Channel
test_image = np.expand_dims(test_image, axis=0)

# Predicting the final class
result = model.predict(test_image)[0].argmax()

# Fetching the class labels
labels = train_iter.class_indices
labels = list(labels.items())

# Printing the final label
for label, i in labels:
    if i == result:
        print("The test image has: ", label)
        break
